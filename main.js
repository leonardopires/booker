/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the repo.
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BookerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/adapters/BookerPanelView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_BOOKER_PANEL = "booker-panel";
var BookerPanelView = class extends import_obsidian.ItemView {
  constructor(leaf, builder, generate, openOutput, presenter) {
    super(leaf);
    this.builder = builder;
    this.generate = generate;
    this.openOutput = openOutput;
    this.presenter = presenter;
    this.activeFile = null;
    this.model = { state: "empty" };
  }
  /**
   * @returns Obsidian view type identifier.
   */
  getViewType() {
    return VIEW_TYPE_BOOKER_PANEL;
  }
  /**
   * @returns Display name for the view tab.
   */
  getDisplayText() {
    return "Booker";
  }
  /**
   * Refresh the panel using the provided active file.
   *
   * @param file - Active file reference or null when no file is active.
   */
  setActiveFile(file) {
    this.activeFile = file;
    this.model = this.builder.build(file);
    this.render();
  }
  /**
   * Initialize the panel container when the view opens.
   */
  async onOpen() {
    this.render();
  }
  /**
   * Render the current view model into the panel container.
   */
  render() {
    const root = this.contentEl;
    this.clearElement(root);
    root.classList.add("booker-panel__root");
    const header = this.createElement(root, "div", "booker-panel__header");
    this.createElement(header, "span", "booker-panel__title", "Booker");
    if (this.model.state === "booker") {
      const badge = this.createElement(header, "span", "booker-panel__badge");
      badge.textContent = this.model.kind === "recipe" ? "Recipe" : "Bundle";
    }
    if (this.model.state === "empty") {
      this.createElement(root, "div", "booker-panel__empty", "No active note selected.");
      return;
    }
    if (this.model.state === "not-booker") {
      this.createElement(root, "div", "booker-panel__empty", "This note is not a Booker recipe or bundle.");
      return;
    }
    const model = this.model;
    const outputLine = this.createElement(root, "div", "booker-panel__output");
    outputLine.append("Output: ");
    if (model.outputPath) {
      const link = this.createElement(outputLine, "a", "booker-panel__output-link");
      link.href = "#";
      link.textContent = model.outputPath;
      link.addEventListener("click", (event) => {
        var _a;
        event.preventDefault();
        const opened = this.openOutput((_a = model.outputPath) != null ? _a : "");
        if (!opened) {
          this.presenter.showInfoForFile(model.fileLabel, "Output not generated yet. Generate first.");
        }
      });
    } else {
      this.createElement(outputLine, "span", "booker-panel__output-empty", "\u2014");
    }
    const summary = this.createElement(root, "div", "booker-panel__summary");
    summary.textContent = `${model.summaryLabel}: ${model.totalCount} (missing: ${model.missingCount})`;
    const list = this.createElement(root, "ul", "booker-panel__list");
    model.items.forEach((item) => {
      const entry = this.createElement(list, "li", "booker-panel__list-item");
      const icon = item.resolved ? "\u2705" : "\u274C";
      entry.textContent = `${icon} ${item.label}`;
    });
    const actions = this.createElement(root, "div", "booker-panel__actions");
    const button = this.createElement(actions, "button", "booker-panel__action-button");
    button.type = "button";
    button.textContent = model.actionLabel;
    button.addEventListener("click", () => {
      if (this.activeFile) {
        void this.generate(this.activeFile);
      }
    });
    const hint = this.createElement(root, "div", "booker-panel__hint");
    hint.textContent = model.hint;
  }
  /**
   * Remove all children from an element.
   */
  clearElement(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  /**
   * Create and append an element with optional class and text.
   */
  createElement(parent, tag, className, text) {
    const element = parent.ownerDocument.createElement(tag);
    if (className) {
      element.className = className;
    }
    if (text !== void 0) {
      element.textContent = text;
    }
    parent.appendChild(element);
    return element;
  }
};

// src/adapters/ObsidianAppContext.ts
var import_obsidian2 = require("obsidian");
var toFileRef = (file) => ({ path: file.path, kind: "file" });
var toFolderRef = (folder) => ({ path: folder.path, kind: "folder" });
var toTFile = (app, file) => {
  const resolved = app.vault.getAbstractFileByPath(file.path);
  if (resolved instanceof import_obsidian2.TFile) {
    return resolved;
  }
  throw new Error(`Booker: File not found: ${file.path}`);
};
var ObsidianVault = class {
  constructor(app) {
    this.app = app;
  }
  async read(file) {
    return this.app.vault.read(toTFile(this.app, file));
  }
  async modify(file, content) {
    await this.app.vault.modify(toTFile(this.app, file), content);
  }
  async create(path, content) {
    const created = await this.app.vault.create(path, content);
    return toFileRef(created);
  }
  async createFolder(path) {
    await this.app.vault.createFolder(path);
  }
  getFileByPath(path) {
    const found = this.app.vault.getAbstractFileByPath(path);
    if (found instanceof import_obsidian2.TFile) {
      return toFileRef(found);
    }
    if (found instanceof import_obsidian2.TFolder) {
      return toFolderRef(found);
    }
    return null;
  }
  listFolderFiles(folder, recursive) {
    const results = [];
    const root = folder.path ? this.app.vault.getAbstractFileByPath(folder.path) : this.app.vault.getRoot();
    if (!(root instanceof import_obsidian2.TFolder)) {
      return results;
    }
    const walk = (current) => {
      for (const child of current.children) {
        if (child instanceof import_obsidian2.TFile) {
          results.push(toFileRef(child));
        } else if (recursive && child instanceof import_obsidian2.TFolder) {
          walk(child);
        }
      }
    };
    walk(root);
    return results;
  }
};
var ObsidianMetadataCache = class {
  constructor(app) {
    this.app = app;
  }
  getFileCache(file) {
    var _a;
    const cache = this.app.metadataCache.getFileCache(toTFile(this.app, file));
    return cache ? { frontmatter: (_a = cache.frontmatter) != null ? _a : void 0 } : null;
  }
  getFirstLinkpathDest(linkpath, fromPath) {
    const resolved = this.app.metadataCache.getFirstLinkpathDest(linkpath, fromPath);
    return resolved ? toFileRef(resolved) : null;
  }
};
var ObsidianNotice = class {
  notify(message) {
    new import_obsidian2.Notice(message);
  }
};
var ObsidianAppContext = class {
  constructor(app) {
    this.vault = new ObsidianVault(app);
    this.metadataCache = new ObsidianMetadataCache(app);
    this.notice = new ObsidianNotice();
  }
};
var createFileRef = (file) => toFileRef(file);

// src/app/BookerContext.ts
var import_obsidian5 = require("obsidian");

// src/adapters/FilenameModal.ts
var import_obsidian3 = require("obsidian");
var FilenameModal = class extends import_obsidian3.Modal {
  constructor(app, titleText, defaultValue) {
    super(app);
    this.titleText = titleText;
    this.defaultValue = defaultValue;
    this.resolvePromise = null;
    this.inputEl = null;
    this.prefillCheckbox = null;
    this.includeSubfoldersCheckbox = null;
    this.didSubmit = false;
  }
  /**
   * Open the modal and resolve with the user input or null if canceled.
   *
   * @returns Promise that resolves to the provided filename data or null.
   */
  openAndGetValue() {
    this.open();
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
  }
  /**
   * Build modal content.
   */
  onOpen() {
    this.clearElement(this.contentEl);
    const title = this.createElement(this.contentEl, "h2");
    title.textContent = this.titleText;
    const input = this.createElement(this.contentEl, "input");
    input.type = "text";
    input.placeholder = "Filename";
    if (this.defaultValue) {
      input.value = this.defaultValue;
    }
    this.inputEl = input;
    const prefillRow = this.createElement(this.contentEl, "label", "booker-panel__modal-checkbox");
    const prefillCheckbox = this.createElement(prefillRow, "input");
    prefillCheckbox.type = "checkbox";
    prefillCheckbox.checked = true;
    this.prefillCheckbox = prefillCheckbox;
    const prefillLabel = this.createElement(prefillRow, "span");
    prefillLabel.textContent = "Pre-fill list from this folder";
    const includeRow = this.createElement(this.contentEl, "label", "booker-panel__modal-checkbox");
    const includeCheckbox = this.createElement(includeRow, "input");
    includeCheckbox.type = "checkbox";
    includeCheckbox.checked = false;
    this.includeSubfoldersCheckbox = includeCheckbox;
    const includeLabel = this.createElement(includeRow, "span");
    includeLabel.textContent = "Include subfolders";
    const buttonRow = this.createElement(this.contentEl, "div", "booker-panel__modal-actions");
    const cancelButton = this.createElement(buttonRow, "button");
    cancelButton.type = "button";
    cancelButton.textContent = "Cancel";
    cancelButton.addEventListener("click", () => this.complete(null));
    const submitButton = this.createElement(buttonRow, "button");
    submitButton.type = "button";
    submitButton.textContent = "Create";
    submitButton.addEventListener("click", () => this.complete(this.buildResult()));
    input.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        this.complete(this.buildResult());
      }
    });
    input.focus();
  }
  /**
   * Resolve with null when the modal is closed without submitting.
   */
  onClose() {
    if (!this.didSubmit) {
      this.complete(null);
      return;
    }
    this.clearElement(this.contentEl);
  }
  /**
   * Resolve the modal promise and close the modal.
   */
  complete(value) {
    if (this.resolvePromise) {
      this.didSubmit = true;
      const resolver = this.resolvePromise;
      this.resolvePromise = null;
      resolver(value);
      this.close();
    }
  }
  /**
   * Build the resolved modal result from current input values.
   */
  buildResult() {
    var _a, _b, _c, _d, _e, _f;
    return {
      filename: (_b = (_a = this.inputEl) == null ? void 0 : _a.value) != null ? _b : "",
      prefillFromFolder: (_d = (_c = this.prefillCheckbox) == null ? void 0 : _c.checked) != null ? _d : true,
      includeSubfolders: (_f = (_e = this.includeSubfoldersCheckbox) == null ? void 0 : _e.checked) != null ? _f : false
    };
  }
  /**
   * Clear all child nodes from an element.
   */
  clearElement(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  /**
   * Create and append a child element with optional class.
   */
  createElement(parent, tag, className) {
    const element = parent.ownerDocument.createElement(tag);
    if (className) {
      element.className = className;
    }
    parent.appendChild(element);
    return element;
  }
};

// src/utils/PathUtils.ts
function normalizePath(path) {
  let normalized = path.replace(/\\/g, "/");
  normalized = normalized.replace(/\/+/g, "/");
  normalized = normalized.replace(/^\.\//, "");
  if (normalized.startsWith("/")) {
    normalized = normalized.slice(1);
  }
  return normalized;
}
function getDirname(path) {
  const normalized = normalizePath(path);
  const lastSlash = normalized.lastIndexOf("/");
  if (lastSlash === -1) {
    return "";
  }
  return normalized.slice(0, lastSlash);
}
function getBasename(path) {
  const normalized = normalizePath(path);
  const lastSlash = normalized.lastIndexOf("/");
  const filename = lastSlash === -1 ? normalized : normalized.slice(lastSlash + 1);
  return filename.endsWith(".md") ? filename.slice(0, -3) : filename;
}

// src/services/BookerFileCreator.ts
var RECIPE_TEMPLATE = `---
type: booker-recipe
title: "$FILENAME$"
output: "output/$FILENAME$.md"
order:
  - "[[]]"
recipe_strip_frontmatter: true
recipe_strip_h1: true
recipe_heading_offset: 1
---

# New Recipe

Describe what this recipe generates.

\u2139\uFE0F Edit the YAML above in Source mode.
`;
var BUNDLE_TEMPLATE = `---
type: booker-bundle
title: "$FILENAME$"
targets:
  - "[[]]"
aggregate_output: "output/$FILENAME$.md"
---

# New Bundle

This bundle combines multiple recipes or bundles.

\u2139\uFE0F Edit the YAML above in Source mode.
`;
var BookerFileCreator = class {
  constructor(context) {
    this.context = context;
  }
  /**
   * Create a new recipe in the target folder or alongside the target file.
   *
   * @param target - Target folder or file reference.
   * @returns The created file ref, or null if creation is canceled.
   */
  async createRecipe(target) {
    return this.createFromTemplate(target, "recipe");
  }
  /**
   * Create a new bundle in the target folder or alongside the target file.
   *
   * @param target - Target folder or file reference.
   * @returns The created file ref, or null if creation is canceled.
   */
  async createBundle(target) {
    return this.createFromTemplate(target, "bundle");
  }
  /**
   * Prompt for a filename, validate it, and create the requested template.
   *
   * @param target - Target folder or file reference.
   * @param kind - Template kind to create.
   * @returns The created file ref, or null if creation is canceled or invalid.
   */
  async createFromTemplate(target, kind) {
    var _a;
    const folder = normalizePath(
      target.kind === "folder" ? target.path : (_a = getDirname(target.path)) != null ? _a : ""
    );
    const defaultName = `New ${kind === "recipe" ? "recipe" : "bundle"}`;
    const promptResult = await this.context.prompt(
      `New ${kind === "recipe" ? "recipe" : "bundle"} filename`,
      defaultName
    );
    if (promptResult === null) {
      return null;
    }
    const trimmed = promptResult.filename.trim();
    if (!trimmed) {
      this.context.presenter.showWarning("Please enter a filename.");
      return null;
    }
    const filename = trimmed.endsWith(".md") ? trimmed : `${trimmed}.md`;
    const path = normalizePath(folder ? `${folder}/${filename}` : filename);
    const existing = this.context.vault.getFileByPath(path);
    if (existing) {
      this.context.presenter.showWarning("That file already exists. Choose a new name.");
      return null;
    }
    const filenameNoExt = filename.endsWith(".md") ? filename.substring(0, filename.length - 3) : filename;
    const template = kind === "recipe" ? RECIPE_TEMPLATE : BUNDLE_TEMPLATE;
    const content = template.replace(/\$FILENAME\$/gm, filenameNoExt);
    const finalContent = promptResult.prefillFromFolder ? await this.applyPrefill(content, {
      folder,
      kind,
      includeSubfolders: promptResult.includeSubfolders,
      excludePath: path
    }) : content;
    const created = await this.context.vault.create(path, finalContent);
    this.context.openFile(created);
    return created;
  }
  /**
   * Replace the order/targets list with a filtered set of wikilinks from the target folder.
   */
  async applyPrefill(content, options) {
    const items = await this.collectPrefillTargets(options);
    const listLines = items.length > 0 ? items : ['  - "[[]]"'];
    const listKey = options.kind === "recipe" ? "order" : "targets";
    const listBlock = `${listKey}:
${listLines.join("\n")}`;
    const placeholder = new RegExp(`${listKey}:\\n  - "\\[\\[\\]\\]"`);
    return content.replace(placeholder, listBlock);
  }
  /**
   * Collect and format wikilinks from the target folder based on the template kind.
   */
  async collectPrefillTargets(options) {
    const folderRef = { path: options.folder, kind: "folder" };
    const candidates = this.context.vault.listFolderFiles(folderRef, options.includeSubfolders);
    const normalizedExclude = normalizePath(options.excludePath);
    const filtered = candidates.map((file) => normalizePath(file.path)).filter((path) => this.isEligiblePath(path, normalizedExclude, options.kind)).sort((a, b) => a.localeCompare(b)).map((path) => {
      const withoutExt = path.endsWith(".md") ? path.slice(0, -3) : path;
      return `  - "[[${withoutExt}]]"`;
    });
    return filtered;
  }
  /**
   * Determine if a path should be included in the prefill list.
   */
  isEligiblePath(path, excludePath, kind) {
    if (!path || path === excludePath) {
      return false;
    }
    if (!path.endsWith(".md")) {
      return false;
    }
    if (path.split("/").includes("output")) {
      return false;
    }
    const fileRef = { path, kind: "file" };
    const frontmatter = this.context.parser.getFrontmatter(fileRef);
    const normalized = this.context.parser.normalizeType(frontmatter == null ? void 0 : frontmatter.type);
    const isBooker = normalized.normalized === "booker-recipe" || normalized.normalized === "booker-bundle";
    return kind === "recipe" ? !isBooker : isBooker;
  }
};

// src/utils/LabelUtils.ts
var resolveFileLabel = (filePath, frontmatter) => {
  const rawTitle = typeof (frontmatter == null ? void 0 : frontmatter.title) === "string" ? frontmatter.title.trim() : "";
  return rawTitle ? rawTitle : getBasename(filePath);
};

// src/services/BookerPanelModelBuilder.ts
var BookerPanelModelBuilder = class {
  constructor(context) {
    this.context = context;
  }
  /**
   * Build the panel view model for the provided file.
   *
   * @param file - Active file reference or null when no file is active.
   * @returns The view model describing what the panel should render.
   */
  build(file) {
    var _a;
    if (!file) {
      return { state: "empty" };
    }
    const frontmatter = this.context.parser.getFrontmatter(file);
    if (!frontmatter) {
      return { state: "not-booker", path: file.path };
    }
    const typeInfo = this.context.parser.normalizeType(frontmatter.type);
    if (!typeInfo.normalized) {
      return { state: "not-booker", path: file.path };
    }
    const kind = typeInfo.normalized === "booker-recipe" ? "recipe" : "bundle";
    const fileLabel = resolveFileLabel(file.path, frontmatter != null ? frontmatter : null);
    const outputPath = this.getOutputPath(frontmatter, file.path, typeInfo.normalized);
    const outputExists = outputPath ? ((_a = this.context.vault.getFileByPath(outputPath)) == null ? void 0 : _a.kind) === "file" : false;
    const { targets, missingCount } = this.getTargets(frontmatter, file.path, typeInfo.normalized);
    const summaryLabel = kind === "recipe" ? "Sources" : "Steps";
    const actionLabel = kind === "recipe" ? "\u{1F4D8} Generate recipe" : "\u{1F4DA} Generate bundle";
    const hint = missingCount > 0 ? "\u26A0\uFE0F Some sources are missing. Fix the YAML in Source mode, then generate again." : `\u2139\uFE0F To change this ${kind}, edit the YAML in Source mode.`;
    return {
      state: "booker",
      kind,
      fileLabel,
      outputPath,
      outputExists,
      summaryLabel,
      totalCount: targets.length,
      missingCount,
      items: targets,
      actionLabel,
      hint
    };
  }
  /**
   * Resolve the output path for a recipe or bundle frontmatter block.
   */
  getOutputPath(frontmatter, sourcePath, type) {
    var _a, _b;
    if (type === "booker-recipe") {
      const recipeFrontmatter = frontmatter;
      if (!recipeFrontmatter.output) {
        return null;
      }
      return this.context.parser.resolveOutputPath(recipeFrontmatter.output, sourcePath);
    }
    const bundleFrontmatter = frontmatter;
    const aggregateOutput = (_b = bundleFrontmatter.aggregate_output) != null ? _b : (_a = bundleFrontmatter.aggregate) == null ? void 0 : _a.output;
    if (!aggregateOutput) {
      return null;
    }
    return this.context.parser.resolveOutputPath(aggregateOutput, sourcePath);
  }
  /**
   * Build list entries and missing counts for the active file.
   */
  getTargets(frontmatter, sourcePath, type) {
    var _a;
    if (type === "booker-recipe") {
      const recipeFrontmatter = frontmatter;
      const order = this.context.parser.normalizeOrder((_a = recipeFrontmatter.order) != null ? _a : []);
      const targets2 = order.map((item) => {
        const resolved = this.resolveLink(item, sourcePath);
        return { label: this.formatLinkLabel(item), resolved };
      });
      const missingCount2 = targets2.filter((target) => !target.resolved).length;
      return { targets: targets2, missingCount: missingCount2 };
    }
    const bundleFrontmatter = frontmatter;
    const rawTargets = Array.isArray(bundleFrontmatter.targets) ? bundleFrontmatter.targets : [];
    const targets = rawTargets.map((target, index) => {
      if (typeof target !== "string") {
        return { label: `Target ${index + 1}`, resolved: false };
      }
      return this.getBundleTarget(target, sourcePath);
    });
    const missingCount = targets.filter((target) => !target.resolved).length;
    return { targets, missingCount };
  }
  /**
   * Build a list entry for a bundle target.
   */
  getBundleTarget(target, sourcePath) {
    const label = this.formatLinkLabel(target);
    const resolved = this.resolveLink(target, sourcePath);
    return { label, resolved };
  }
  /**
   * Normalize a link label for display.
   */
  formatLinkLabel(raw) {
    const normalized = this.context.linkResolver.normalizeLinkString(raw);
    return normalized || raw.trim();
  }
  /**
   * Resolve a link and return whether it exists.
   */
  resolveLink(raw, sourcePath) {
    const normalized = this.context.linkResolver.normalizeLinkString(raw);
    if (!normalized) {
      return false;
    }
    return this.context.metadataCache.getFirstLinkpathDest(normalized, sourcePath) !== null;
  }
};

// src/services/BuildRunner.ts
var import_obsidian4 = require("obsidian");

// src/domain/errors.ts
var BookerError = class extends Error {
  constructor(code, message, details) {
    super(message);
    this.name = "BookerError";
    this.code = code;
    this.details = details;
  }
};

// src/services/BuildReporter.ts
var BuildReporter = class {
  constructor(presenter) {
    this.presenter = presenter;
    this.events = [];
    this.counts = { success: 0, warning: 0, error: 0 };
  }
  /**
   * Record an info notice for a file.
   */
  info(fileLabel, message) {
    this.record("info", fileLabel, message);
  }
  /**
   * Record a success notice for a file.
   */
  success(fileLabel, message) {
    this.record("success", fileLabel, message);
  }
  /**
   * Record a warning notice for a file.
   */
  warning(fileLabel, message) {
    this.record("warning", fileLabel, message);
  }
  /**
   * Record an error notice for a file.
   */
  error(fileLabel, message) {
    this.record("error", fileLabel, message);
  }
  /**
   * Emit a notice without affecting aggregate counts.
   */
  announce(level, fileLabel, message) {
    const event = { level, fileLabel, message };
    this.events.push(event);
    switch (level) {
      case "success":
        this.presenter.showSuccessForFile(fileLabel, message);
        return;
      case "warning":
        this.presenter.showWarningForFile(fileLabel, message);
        return;
      case "error":
        this.presenter.showErrorForFile(fileLabel, message);
        return;
      case "info":
      default:
        this.presenter.showInfoForFile(fileLabel, message);
    }
  }
  /**
   * Return the aggregated build report.
   */
  getReport() {
    return {
      status: this.getStatus(),
      counts: { ...this.counts },
      events: [...this.events]
    };
  }
  record(level, fileLabel, message) {
    const event = { level, fileLabel, message };
    this.events.push(event);
    switch (level) {
      case "success":
        this.counts.success += 1;
        this.presenter.showSuccessForFile(fileLabel, message);
        return;
      case "warning":
        this.counts.warning += 1;
        this.presenter.showWarningForFile(fileLabel, message);
        return;
      case "error":
        this.counts.error += 1;
        this.presenter.showErrorForFile(fileLabel, message);
        return;
      case "info":
      default:
        this.presenter.showInfoForFile(fileLabel, message);
    }
  }
  getStatus() {
    if (this.counts.error > 0) {
      return "error";
    }
    if (this.counts.warning > 0) {
      return "warning";
    }
    return "success";
  }
};

// src/services/BuildRunner.ts
var BuildRunner = class {
  constructor(context) {
    this.context = context;
    this.rawFrontmatterCache = /* @__PURE__ */ new Map();
  }
  /**
   * Build the provided file as a Booker recipe or bundle.
   *
   * @param file - The file reference to build.
   * @param callStack - Optional call stack used to detect bundle cycles.
   * @param execOpts - Internal execution options (e.g., TOC emission control).
   * @returns The build outcome, including any generated artifact and report.
   */
  async buildCurrentFile(file, callStack = [], execOpts) {
    const reporter = new BuildReporter(this.context.presenter);
    const frontmatterResult = await this.getFrontmatterWithDiagnostics(file);
    if (frontmatterResult.error) {
      this.reportYamlError(file, frontmatterResult.error, reporter);
      return { report: reporter.getReport() };
    }
    const frontmatter = frontmatterResult.frontmatter;
    const fileLabel = resolveFileLabel(file.path, frontmatter != null ? frontmatter : null);
    if (!frontmatter) {
      this.handleError(new BookerError("INVALID_TYPE", "INVALID_TYPE"), fileLabel, reporter);
      return { report: reporter.getReport() };
    }
    const typeInfo = this.context.parser.normalizeType(frontmatter.type);
    if (!typeInfo.normalized) {
      this.handleError(new BookerError("INVALID_TYPE", "INVALID_TYPE"), fileLabel, reporter);
      return { report: reporter.getReport() };
    }
    this.warnIfDeprecated(file.path, frontmatter.type, typeInfo.deprecated, fileLabel, reporter);
    await this.reportFrontmatterDeprecations(
      file,
      frontmatter,
      typeInfo.normalized,
      frontmatterResult.rawFrontmatter,
      fileLabel,
      reporter
    );
    try {
      if (typeInfo.normalized === "booker-recipe") {
        const recipeFrontmatter = frontmatter;
        const artifact = await this.buildRecipe(file, recipeFrontmatter, fileLabel, reporter, execOpts);
        if (artifact) {
          reporter.success(fileLabel, "Generation completed successfully.");
          return { artifactPath: artifact.artifactPath, report: reporter.getReport() };
        }
        return { report: reporter.getReport() };
      }
      const bundleFrontmatter = frontmatter;
      const bundleOutcome = await this.buildBundle(
        file,
        callStack,
        reporter,
        fileLabel,
        bundleFrontmatter,
        execOpts
      );
      if (bundleOutcome.artifact) {
        return {
          artifactPath: bundleOutcome.artifact.artifactPath,
          result: bundleOutcome.result,
          report: reporter.getReport()
        };
      }
      return { result: bundleOutcome.result, report: reporter.getReport() };
    } catch (error) {
      this.handleError(error, fileLabel, reporter);
      return { report: reporter.getReport() };
    }
  }
  /**
   * Build a bundle, optionally suppressing TOC emission for nested targets.
   *
   * When aggregate TOC is enabled, bundle targets are built with TOC emission suppressed.
   */
  async buildBundle(file, callStack, reporter, bundleLabel, frontmatter, execOpts) {
    var _a, _b, _c;
    const normalizedPath = normalizePath(file.path);
    if (callStack.includes(normalizedPath)) {
      throw this.createCycleError([...callStack, normalizedPath]);
    }
    const typeInfo = this.context.parser.normalizeType(frontmatter.type);
    if (typeInfo.normalized !== "booker-bundle") {
      throw new BookerError("INVALID_TYPE", "INVALID_TYPE");
    }
    const bundleConfig = this.context.parser.parseBundleConfig(frontmatter, file);
    const bundleName = getBasename(file.path);
    if (!((_a = bundleConfig.aggregate) == null ? void 0 : _a.outputPath)) {
      throw new BookerError("BUNDLE_MISSING_AGGREGATE_OUTPUT", bundleName);
    }
    reporter.info(bundleLabel, `Running ${bundleConfig.targets.length} targets\u2026`);
    const stack = [...callStack, normalizedPath];
    const results = [];
    const successfulChunks = [];
    const outputPaths = [];
    const aggregatedHeadings = [];
    const summaryCounts = { success: 0, warning: 0, error: 0 };
    const aggregateTocEnabled = (_c = (_b = bundleConfig.aggregate) == null ? void 0 : _b.options.toc) != null ? _c : false;
    const targetExecOpts = (execOpts == null ? void 0 : execOpts.tocEmission) === "suppress" ? execOpts : aggregateTocEnabled ? { tocEmission: "suppress" } : execOpts;
    for (const target of bundleConfig.targets) {
      const targetStartCounts = reporter.getReport().counts;
      const targetResult = await this.buildBundleTarget(
        target,
        file,
        stack,
        bundleConfig.buildOptions,
        reporter,
        targetExecOpts
      );
      const targetEndCounts = reporter.getReport().counts;
      const targetDelta = this.diffCounts(targetEndCounts, targetStartCounts);
      const targetStatus = this.getStatusFromCounts(targetDelta);
      summaryCounts[targetStatus] += 1;
      results.push(targetResult.result);
      if (targetResult.artifact) {
        successfulChunks.push({
          content: targetResult.artifact.content,
          basename: getBasename(targetResult.artifact.artifactPath),
          sourcePath: targetResult.artifact.artifactPath
        });
        outputPaths.push(normalizePath(targetResult.artifact.artifactPath));
        aggregatedHeadings.push(...targetResult.artifact.headings);
      }
      if (!targetResult.result.success && bundleConfig.buildOptions.stop_on_error) {
        break;
      }
    }
    const aggregate = await this.aggregateBundleOutputs(
      bundleConfig.aggregate,
      outputPaths,
      successfulChunks,
      bundleConfig,
      bundleName,
      aggregatedHeadings,
      execOpts
    );
    const successes = results.filter((result) => result.success).length;
    const failures = results.filter((result) => !result.success).length;
    const missingTotal = results.reduce((total, result) => total + result.missingLinks.length, 0);
    const buildResult = {
      targets: results,
      successes,
      failures,
      missingTotal,
      aggregate: {
        attempted: true,
        success: !!aggregate,
        outputPath: aggregate == null ? void 0 : aggregate.outputPath
      }
    };
    const bundleStatus = this.getStatusFromCounts(summaryCounts);
    this.reportBundleSummary(bundleLabel, reporter, summaryCounts, bundleStatus);
    return {
      artifact: aggregate ? {
        artifactPath: aggregate.outputPath,
        content: aggregate.content,
        headings: aggregate.headings
      } : null,
      result: buildResult
    };
  }
  /**
   * Build a single bundle target, respecting TOC emission controls from execOpts.
   */
  async buildBundleTarget(target, bundleFile, callStack, buildOptions, reporter, execOpts) {
    const resolved = this.resolveSourceFile(target, bundleFile.path);
    const targetName = getBasename(resolved.path);
    const frontmatterResult = await this.getFrontmatterWithDiagnostics(resolved);
    const targetFrontmatter = frontmatterResult.frontmatter;
    const targetLabel = resolveFileLabel(resolved.path, targetFrontmatter != null ? targetFrontmatter : null);
    if (frontmatterResult.error) {
      this.reportYamlError(resolved, frontmatterResult.error, reporter);
      return {
        result: {
          name: targetName,
          outputPath: "",
          missingLinks: [],
          skippedSelfIncludes: [],
          success: false,
          resolvedCount: 0
        }
      };
    }
    if (!targetFrontmatter) {
      this.handleError(new BookerError("INVALID_TYPE", "INVALID_TYPE"), targetLabel, reporter);
      return {
        result: {
          name: targetName,
          outputPath: "",
          missingLinks: [],
          skippedSelfIncludes: [],
          success: false,
          resolvedCount: 0
        }
      };
    }
    const typeInfo = this.context.parser.normalizeType(targetFrontmatter.type);
    if (!typeInfo.normalized) {
      this.handleError(new BookerError("INVALID_TYPE", "INVALID_TYPE"), targetLabel, reporter);
      return {
        result: {
          name: targetName,
          outputPath: "",
          missingLinks: [],
          skippedSelfIncludes: [],
          success: false,
          resolvedCount: 0
        }
      };
    }
    this.warnIfDeprecated(resolved.path, targetFrontmatter.type, typeInfo.deprecated, targetLabel, reporter);
    await this.reportFrontmatterDeprecations(
      resolved,
      targetFrontmatter,
      typeInfo.normalized,
      frontmatterResult.rawFrontmatter,
      targetLabel,
      reporter
    );
    if (typeInfo.normalized === "booker-recipe") {
      try {
        const recipeConfig = this.context.parser.parseRecipeConfig(
          targetFrontmatter,
          resolved
        );
        const compileResult = await this.context.compiler.compile(recipeConfig, resolved.path, execOpts);
        const targetResult = this.createTargetResult(targetName, recipeConfig.outputPath, compileResult);
        return this.handleCompileResult(
          recipeConfig,
          compileResult,
          buildOptions,
          targetResult,
          targetLabel,
          reporter
        );
      } catch (error) {
        this.handleError(error, targetLabel, reporter);
        return {
          result: {
            name: targetName,
            outputPath: "",
            missingLinks: [],
            skippedSelfIncludes: [],
            success: false,
            resolvedCount: 0
          }
        };
      }
    }
    const bundleFrontmatter = targetFrontmatter;
    const bundleOutcome = await this.buildBundle(
      resolved,
      callStack,
      reporter,
      targetLabel,
      bundleFrontmatter,
      execOpts
    );
    if (!bundleOutcome.artifact) {
      const targetResult = {
        name: targetName,
        outputPath: "",
        missingLinks: [],
        skippedSelfIncludes: [],
        success: false,
        resolvedCount: 0
      };
      return { result: targetResult };
    }
    return {
      result: {
        name: targetName,
        outputPath: bundleOutcome.artifact.artifactPath,
        missingLinks: [],
        skippedSelfIncludes: [],
        success: true,
        resolvedCount: 1
      },
      artifact: bundleOutcome.artifact
    };
  }
  async handleCompileResult(config, compileResult, buildOptions, targetResult, fileLabel, reporter) {
    if (compileResult.missingLinks.length > 0) {
      console.warn(`Booker: Missing files for ${config.outputPath}:`, compileResult.missingLinks);
    }
    if (compileResult.skippedSelfIncludes.length > 0) {
      console.warn(`Booker: Skipped self-inclusion for ${config.outputPath}:`, compileResult.skippedSelfIncludes);
      reporter.warning(
        fileLabel,
        "I skipped one step to avoid a loop.\nA file tried to include its own output."
      );
    }
    let success = compileResult.resolvedCount > 0;
    if (compileResult.missingLinks.length > 0 && !buildOptions.continue_on_missing) {
      success = false;
    }
    const result = {
      ...targetResult,
      success
    };
    if (success && !buildOptions.dry_run) {
      await this.context.compiler.writeOutput(config.outputPath, compileResult.content);
    }
    if (success) {
      reporter.success(fileLabel, "Generation completed successfully.");
    } else {
      reporter.error(fileLabel, "Generation failed.");
    }
    return success ? {
      result,
      artifact: {
        artifactPath: config.outputPath,
        content: compileResult.content,
        headings: compileResult.headings
      }
    } : { result };
  }
  async aggregateBundleOutputs(aggregate, outputPaths, successfulChunks, bundleConfig, bundleName, aggregatedHeadings, execOpts) {
    if (!aggregate) {
      throw new BookerError("BUNDLE_MISSING_AGGREGATE_OUTPUT", bundleName);
    }
    if (successfulChunks.length === 0) {
      return null;
    }
    if (outputPaths.includes(normalizePath(aggregate.outputPath))) {
      throw new BookerError("AGGREGATE_OUTPUT_CONFLICT", "AGGREGATE_OUTPUT_CONFLICT");
    }
    const tocHeadingsOverride = aggregate.options.toc_scope === "tree" ? aggregatedHeadings : void 0;
    const aggregateResult = this.context.compiler.compileFromChunks(
      successfulChunks,
      {
        title: aggregate.title,
        outputPath: aggregate.outputPath,
        order: [],
        options: aggregate.options
      },
      tocHeadingsOverride,
      execOpts
    );
    if (!bundleConfig.buildOptions.dry_run) {
      await this.context.compiler.writeOutput(aggregate.outputPath, aggregateResult.content);
    }
    const bundleHeadings = aggregate.title ? [{ level: 1, text: aggregate.title, sourcePath: aggregate.outputPath }, ...aggregatedHeadings] : aggregatedHeadings;
    return {
      outputPath: aggregate.outputPath,
      content: aggregateResult.content,
      headings: bundleHeadings.length > 0 ? bundleHeadings : aggregateResult.headings
    };
  }
  /**
   * Build a recipe, optionally suppressing TOC emission via execOpts.
   */
  async buildRecipe(file, frontmatter, fileLabel, reporter, execOpts) {
    const config = this.context.parser.parseRecipeConfig(frontmatter, file);
    const result = await this.context.compiler.compile(config, file.path, execOpts);
    if (result.skippedSelfIncludes.length > 0) {
      console.warn(`Booker: Skipped self-inclusion for ${file.path}:`, result.skippedSelfIncludes);
      reporter.warning(
        fileLabel,
        "I skipped one step to avoid a loop.\nA file tried to include its own output."
      );
    }
    if (result.missingLinks.length > 0) {
      console.warn(`Booker: Missing files for ${file.path}:`, result.missingLinks);
    }
    if (result.resolvedCount === 0) {
      reporter.error(fileLabel, "Generation failed.");
      return null;
    }
    await this.context.compiler.writeOutput(config.outputPath, result.content);
    return {
      artifactPath: config.outputPath,
      content: result.content,
      headings: result.headings
    };
  }
  resolveSourceFile(source, fromPath) {
    const linkpath = this.context.linkResolver.normalizeLinkString(source);
    const resolved = this.context.linkResolver.resolveToFile(linkpath, fromPath);
    if (!resolved) {
      throw new BookerError("SOURCE_NOT_FOUND", linkpath);
    }
    return resolved;
  }
  createTargetResult(name, outputPath, compileResult) {
    return {
      name,
      outputPath,
      missingLinks: compileResult.missingLinks,
      skippedSelfIncludes: compileResult.skippedSelfIncludes,
      success: false,
      resolvedCount: compileResult.resolvedCount
    };
  }
  warnIfDeprecated(path, rawType, deprecated, fileLabel, reporter) {
    if (!deprecated) {
      return;
    }
    const message = "This note uses a deprecated Booker type. Update to `type: booker-recipe` or `type: booker-bundle`.";
    reporter.warning(fileLabel, message);
    console.warn(`Booker: Deprecated type "${String(rawType)}" in ${path}.`);
  }
  async reportFrontmatterDeprecations(file, frontmatter, type, rawFrontmatter, fileLabel, reporter) {
    let warnings = this.context.parser.getDeprecationWarnings(frontmatter, type, rawFrontmatter != null ? rawFrontmatter : void 0);
    if (warnings.length === 0) {
      return;
    }
    if (!rawFrontmatter) {
      const raw = await this.getRawFrontmatter(file);
      if (raw) {
        warnings = this.context.parser.getDeprecationWarnings(frontmatter, type, raw);
      }
    }
    for (const warning of warnings) {
      const location = warning.location ? ` (line ${warning.location.line}${warning.location.column !== null ? `, col ${warning.location.column}` : ""})` : "";
      const keys = warning.keys.length > 0 ? ` [${warning.keys.join(", ")}]` : "";
      reporter.warning(fileLabel, `${warning.category}${location}: ${warning.hint}${keys ? ` ${keys}` : ""}`);
    }
  }
  async getRawFrontmatter(file) {
    var _a;
    if (this.rawFrontmatterCache.has(file.path)) {
      return (_a = this.rawFrontmatterCache.get(file.path)) != null ? _a : null;
    }
    const content = await this.context.vault.read(file);
    const extracted = this.extractFrontmatter(content);
    const raw = extracted && "content" in extracted ? extracted.content : null;
    this.rawFrontmatterCache.set(file.path, raw != null ? raw : null);
    return raw != null ? raw : null;
  }
  createCycleError(callStack) {
    const cycle = callStack.map((path) => getBasename(path)).join(" \u2192 ");
    return new BookerError("CYCLE_DETECTED", cycle);
  }
  handleError(error, fileLabel, reporter) {
    const { message, severity } = this.formatUserMessage(error);
    if (severity === "warning") {
      reporter.warning(fileLabel, message);
      return;
    }
    reporter.error(fileLabel, message);
  }
  formatUserMessage(error) {
    if (error instanceof BookerError) {
      switch (error.code) {
        case "INVALID_TYPE":
          return {
            message: "This note isn\u2019t a Booker recipe or bundle.\nAdd `type: booker-recipe` or `type: booker-bundle` at the top.",
            severity: "error"
          };
        case "DEPRECATED_BUNDLE_SCHEMA":
          return {
            message: "This bundle uses the deprecated target schema.\nUpdate `targets` to a simple list of wikilinks or paths, then generate again.",
            severity: "warning"
          };
        case "MISSING_OUTPUT":
          return {
            message: 'This recipe has no output file.\nAdd `output: "path/to/file.md"` to the YAML.',
            severity: "error"
          };
        case "MISSING_ORDER":
          return {
            message: "This recipe has no sources yet.\nAdd an `order:` list with note links.",
            severity: "error"
          };
        case "MISSING_TARGETS":
          return {
            message: "This bundle has no targets yet.\nAdd a `targets:` list with note links.",
            severity: "error"
          };
        case "SOURCE_NOT_FOUND":
          return {
            message: `I couldn\u2019t find the note \u2018${error.message}\u2019.
Check the name or create the note.`,
            severity: "error"
          };
        case "BUNDLE_MISSING_AGGREGATE_OUTPUT":
          return {
            message: `The bundle \u2018${error.message}\u2019 has no final output.
Add \`aggregate.output\` so it can be used here.`,
            severity: "error"
          };
        case "CYCLE_DETECTED":
          return {
            message: `These bundles reference each other in a loop:
${error.message}.
Break the loop to continue.`,
            severity: "error"
          };
        case "AGGREGATE_OUTPUT_CONFLICT":
          return {
            message: "This bundle\u2019s final output conflicts with one of its targets.\nChoose a different `aggregate.output`.",
            severity: "error"
          };
        default:
          break;
      }
    }
    console.error("Booker: Unhandled error", error);
    return {
      message: "Something went wrong while generating.\nCheck the console for details.",
      severity: "error"
    };
  }
  reportBundleSummary(bundleLabel, reporter, counts, status) {
    if (status === "error") {
      reporter.announce(
        "error",
        bundleLabel,
        `Failed (\u2705${counts.success} \u26A0\uFE0F${counts.warning} \u274C${counts.error})`
      );
      return;
    }
    if (status === "warning") {
      reporter.announce(
        "warning",
        bundleLabel,
        `Completed with warnings (\u2705${counts.success} \u26A0\uFE0F${counts.warning} \u274C${counts.error})`
      );
      return;
    }
    reporter.announce(
      "success",
      bundleLabel,
      `Completed (\u2705${counts.success} \u26A0\uFE0F${counts.warning} \u274C${counts.error})`
    );
  }
  diffCounts(current, baseline) {
    return {
      success: Math.max(0, current.success - baseline.success),
      warning: Math.max(0, current.warning - baseline.warning),
      error: Math.max(0, current.error - baseline.error)
    };
  }
  getStatusFromCounts(counts) {
    if (counts.error > 0) {
      return "error";
    }
    if (counts.warning > 0) {
      return "warning";
    }
    return "success";
  }
  async getFrontmatterWithDiagnostics(file) {
    const frontmatter = this.context.parser.getFrontmatter(file);
    if (frontmatter) {
      return { frontmatter, error: null, rawFrontmatter: null };
    }
    const content = await this.context.vault.read(file);
    const extracted = this.extractFrontmatter(content);
    if (!extracted) {
      return { frontmatter: null, error: null, rawFrontmatter: null };
    }
    if (extracted.error) {
      return { frontmatter: null, error: extracted.error, rawFrontmatter: null };
    }
    try {
      const parsed = (0, import_obsidian4.parseYaml)(extracted.content);
      return {
        frontmatter: parsed != null ? parsed : null,
        error: null,
        rawFrontmatter: extracted.content
      };
    } catch (error) {
      return {
        frontmatter: null,
        error: this.formatYamlError(error),
        rawFrontmatter: extracted.content
      };
    }
  }
  reportYamlError(file, error, reporter) {
    const label = resolveFileLabel(file.path, null);
    const location = error.line !== null ? ` (line ${error.line}${error.column !== null ? `, col ${error.column}` : ""})` : "";
    reporter.error(label, `YAML syntax error${location}: ${error.reason}`);
    reporter.info(
      label,
      "Hint: Check indentation, ensure each key has a ':' and list items start with '-'."
    );
  }
  extractFrontmatter(content) {
    var _a;
    const lines = content.split(/\r?\n/);
    if (((_a = lines[0]) == null ? void 0 : _a.trim()) !== "---") {
      return null;
    }
    for (let index = 1; index < lines.length; index += 1) {
      const line = lines[index];
      if (!line) {
        continue;
      }
      if (line.trim() === "---" || line.trim() === "...") {
        return { content: lines.slice(1, index).join("\n"), error: null };
      }
    }
    const lastContentIndex = [...lines].reverse().findIndex((line) => line.trim().length > 0);
    const lastLineNumber = lastContentIndex >= 0 ? lines.length - lastContentIndex : lines.length;
    return {
      content: null,
      error: {
        reason: "Missing closing '---' for YAML frontmatter.",
        line: lastLineNumber,
        column: null
      }
    };
  }
  formatYamlError(error) {
    var _a, _b, _c, _d, _e, _f;
    const errorObject = error;
    const rawMessage = typeof errorObject.message === "string" ? errorObject.message : "Invalid YAML.";
    const trimmedMessage = (_b = (_a = rawMessage.split("\n")[0]) == null ? void 0 : _a.replace(/^YAMLException:\s*/u, "")) != null ? _b : "Invalid YAML.";
    const markLine = (_d = (_c = errorObject.mark) == null ? void 0 : _c.line) != null ? _d : errorObject.line;
    const markColumn = (_f = (_e = errorObject.mark) == null ? void 0 : _e.column) != null ? _f : errorObject.column;
    const line = typeof markLine === "number" ? markLine + 1 : null;
    const column = typeof markColumn === "number" ? markColumn + 1 : null;
    return {
      reason: trimmedMessage || "Invalid YAML.",
      line,
      column
    };
  }
};

// src/services/Compiler.ts
var Compiler = class {
  constructor(context) {
    this.context = context;
  }
  /**
   * Compile a recipe into a single Markdown output string.
   *
   * @param config - Recipe configuration to compile.
   * @param contextPath - Path used to resolve relative links.
   * @param execOpts - Internal execution options (e.g., TOC emission control).
   * @returns Compilation result with content and diagnostics.
   */
  async compile(config, contextPath, execOpts) {
    const resolvedFiles = [];
    const missingLinks = [];
    const skippedSelfIncludes = [];
    const normalizedOutput = normalizePath(config.outputPath);
    for (const item of config.order) {
      const linkpath = this.context.linkResolver.normalizeLinkString(item);
      const resolved = this.context.linkResolver.resolveToFile(linkpath, contextPath);
      if (!resolved) {
        missingLinks.push(linkpath);
        continue;
      }
      const resolvedPath = normalizePath(resolved.path);
      if (resolvedPath === normalizedOutput) {
        skippedSelfIncludes.push(resolvedPath);
        continue;
      }
      resolvedFiles.push(resolved);
    }
    const { content, headings } = await this.compileFromFiles(resolvedFiles, config, execOpts);
    return {
      content,
      headings,
      missingLinks,
      skippedSelfIncludes,
      resolvedCount: resolvedFiles.length
    };
  }
  /**
   * Compile a recipe and optionally persist the output.
   *
   * @param config - Recipe configuration to compile.
   * @param contextPath - Path used to resolve relative links.
   * @param dryRun - When true, skip writing output to the vault.
   * @param execOpts - Internal execution options (e.g., TOC emission control).
   * @returns Target result containing output status and diagnostics.
   */
  async compileAndWrite(config, contextPath, dryRun, execOpts) {
    var _a;
    const result = await this.compile(config, contextPath, execOpts);
    const success = result.resolvedCount > 0;
    if (success && !dryRun) {
      const outputFile = await this.context.vaultIO.ensureOutputFile(config.outputPath);
      await this.context.vaultIO.write(outputFile, result.content);
    }
    return {
      name: (_a = config.title) != null ? _a : "Booker Project",
      outputPath: config.outputPath,
      missingLinks: result.missingLinks,
      skippedSelfIncludes: result.skippedSelfIncludes,
      success,
      resolvedCount: result.resolvedCount
    };
  }
  /**
   * Compile Markdown chunks into a single output string.
   *
   * @param chunks - Ordered list of content chunks.
   * @param config - Recipe configuration used for transforms.
   * @param tocHeadingsOverride - Optional headings list to use for TOC rendering.
   * @param execOpts - Internal execution options; TOC insertion is skipped when tocEmission is "suppress".
   * @returns Combined Markdown content and extracted headings (pre-TOC insertion).
   */
  compileFromChunks(chunks, config, tocHeadingsOverride, execOpts) {
    var _a, _b, _c;
    const headings = [];
    const pieces = chunks.map((chunk) => {
      let content = this.context.markdownTransform.apply(chunk.content, config.options);
      if (!config.options.strip_title) {
        content = this.ensureFilenameTitle(content, chunk.basename);
      }
      content = this.context.markdownTransform.applyHeadingOffset(content, config.options);
      headings.push(...this.context.markdownTransform.extractHeadings(content, chunk.sourcePath));
      return content.trim();
    });
    const titlePrefix = config.title ? `# ${config.title}` : "";
    if (titlePrefix) {
      headings.unshift({
        level: 1,
        text: (_a = config.title) != null ? _a : "",
        sourcePath: config.outputPath
      });
    }
    const joined = this.context.markdownTransform.joinChunks(pieces, config.options.separator);
    const titleBlock = titlePrefix ? `${titlePrefix}

` : "";
    const baseContent = `${titleBlock}${joined}`.trimEnd();
    const tocHeadings = tocHeadingsOverride ? [
      ...titlePrefix ? [{ level: 1, text: (_b = config.title) != null ? _b : "", sourcePath: config.outputPath }] : [],
      ...tocHeadingsOverride
    ] : headings;
    const effectiveTocEmission = (_c = execOpts == null ? void 0 : execOpts.tocEmission) != null ? _c : "emit";
    const contentWithToc = effectiveTocEmission === "suppress" ? `${baseContent}
` : this.context.tocBuilder.apply(
      `${baseContent}
`,
      tocHeadings,
      config.options,
      !!titlePrefix
    );
    return {
      content: contentWithToc,
      headings
    };
  }
  /**
   * Persist content to the given vault path.
   *
   * @param path - Output file path.
   * @param content - Content to write.
   */
  async writeOutput(path, content) {
    const outputFile = await this.context.vaultIO.ensureOutputFile(path);
    await this.context.vaultIO.write(outputFile, content);
  }
  async compileFromFiles(files, config, execOpts) {
    const chunks = [];
    for (const file of files) {
      const content = await this.context.vaultIO.read(file);
      chunks.push({ content, basename: getBasename(file.path), sourcePath: file.path });
    }
    return this.compileFromChunks(chunks, config, void 0, execOpts);
  }
  ensureFilenameTitle(content, filename) {
    const titleLine = `# ${filename}`;
    const trimmed = content.trimStart();
    if (trimmed.startsWith(`${titleLine}
`) || trimmed === titleLine) {
      return content;
    }
    return `${titleLine}

${content.trimStart()}`;
  }
};

// src/domain/types.ts
var DEFAULT_BOOKER_OPTIONS = {
  strip_frontmatter: true,
  strip_h1: false,
  strip_title: false,
  separator: "\n\n---\n\n",
  heading_offset: 1,
  toc: false,
  toc_title: "Table of Contents",
  toc_scope: "tree",
  toc_depth: 4,
  toc_include_h1: true
};
var DEFAULT_BUILD_OPTIONS = {
  stop_on_error: true,
  continue_on_missing: false,
  dry_run: false,
  summary_notice: true
};

// src/services/FrontmatterParser.ts
var OPTION_KEYS = [
  "strip_frontmatter",
  "strip_h1",
  "strip_title",
  "separator",
  "heading_offset",
  "toc",
  "toc_title",
  "toc_scope",
  "toc_depth",
  "toc_include_h1"
];
var FrontmatterParser = class {
  constructor(metadataCache) {
    this.metadataCache = metadataCache;
  }
  /**
   * Fetch cached frontmatter for a file when available.
   *
   * @param file - File reference to look up.
   * @returns Parsed frontmatter or null when missing.
   */
  getFrontmatter(file) {
    var _a;
    const cache = this.metadataCache.getFileCache(file);
    return (_a = cache == null ? void 0 : cache.frontmatter) != null ? _a : null;
  }
  /**
   * Normalize Booker frontmatter types and mark deprecated aliases.
   */
  normalizeType(rawType) {
    if (typeof rawType !== "string") {
      return { deprecated: false };
    }
    if (rawType === "booker-recipe") {
      return { normalized: "booker-recipe", deprecated: false };
    }
    if (rawType === "booker-bundle") {
      return { normalized: "booker-bundle", deprecated: false };
    }
    if (rawType === "booker") {
      return { normalized: "booker-recipe", deprecated: true };
    }
    if (rawType === "booker-build") {
      return { normalized: "booker-bundle", deprecated: true };
    }
    return { deprecated: false };
  }
  /**
   * Parse a Booker recipe configuration from frontmatter, including legacy schemas.
   */
  parseRecipeConfig(frontmatter, file) {
    const output = this.readString(frontmatter.output);
    if (!output) {
      throw new BookerError("MISSING_OUTPUT", "MISSING_OUTPUT");
    }
    const order = this.normalizeOrder(frontmatter.order);
    if (order.length === 0) {
      throw new BookerError("MISSING_ORDER", "MISSING_ORDER");
    }
    const options = this.resolveRecipeOptions(frontmatter);
    return {
      title: frontmatter.title,
      outputPath: this.resolveOutputPath(output, file.path),
      order,
      options: {
        ...DEFAULT_BOOKER_OPTIONS,
        ...options
      }
    };
  }
  /**
   * Parse a Booker bundle configuration from frontmatter, including legacy schemas.
   */
  parseBundleConfig(frontmatter, file) {
    if (!Array.isArray(frontmatter.targets) || frontmatter.targets.length === 0) {
      throw new BookerError("MISSING_TARGETS", "MISSING_TARGETS");
    }
    const targets = this.parseBundleTargets(frontmatter.targets);
    const aggregate = this.normalizeAggregateConfig(frontmatter, file);
    const buildOptions = this.resolveBuildOptions(frontmatter);
    return {
      targets,
      aggregate,
      buildOptions: {
        ...DEFAULT_BUILD_OPTIONS,
        ...buildOptions
      }
    };
  }
  /**
   * Resolve bundle/recipe output paths relative to the active file.
   */
  resolveOutputPath(output, activePath) {
    const trimmed = output.trim();
    if (trimmed.startsWith("~")) {
      const rootPath = trimmed.slice(1);
      const normalizedRoot = rootPath.startsWith("/") ? rootPath.slice(1) : rootPath;
      return normalizePath(normalizedRoot);
    }
    const dir = getDirname(activePath);
    if (!dir) {
      return normalizePath(trimmed);
    }
    return normalizePath(`${dir}/${trimmed}`);
  }
  /**
   * Normalize and filter a recipe order list.
   */
  normalizeOrder(order) {
    if (!Array.isArray(order)) {
      return [];
    }
    return order.filter((item) => typeof item === "string");
  }
  normalizeAggregateConfig(frontmatter, file) {
    var _a, _b, _c, _d, _e;
    const hasAggregateBlock = !!frontmatter.aggregate;
    const hasAggregateFields = typeof frontmatter.aggregate_output === "string" || typeof frontmatter.aggregate_title === "string" || this.hasAggregateOptionOverrides(frontmatter);
    const output = (_b = this.readString(frontmatter.aggregate_output)) != null ? _b : this.readString((_a = frontmatter.aggregate) == null ? void 0 : _a.output);
    if (!output) {
      if (hasAggregateBlock || hasAggregateFields) {
        throw new BookerError("MISSING_AGGREGATE_OUTPUT", "MISSING_AGGREGATE_OUTPUT");
      }
      return void 0;
    }
    const title = (_d = this.readString(frontmatter.aggregate_title)) != null ? _d : this.readString((_c = frontmatter.aggregate) == null ? void 0 : _c.title);
    const prefixedOptions = this.readAggregatePrefixedOptions(frontmatter);
    const nestedOptions = this.readOptionsFromObject((_e = frontmatter.aggregate) == null ? void 0 : _e.options);
    const unprefixedOptions = this.readOptionsFromObject(frontmatter);
    const resolvedOptions = this.resolveOptionSources(prefixedOptions, nestedOptions, unprefixedOptions);
    return {
      title,
      outputPath: this.resolveOutputPath(output, file.path),
      options: {
        ...DEFAULT_BOOKER_OPTIONS,
        ...resolvedOptions
      }
    };
  }
  parseBundleTargets(targets) {
    if (!Array.isArray(targets)) {
      return [];
    }
    const invalid = targets.some((target) => typeof target !== "string");
    if (invalid) {
      throw new BookerError("DEPRECATED_BUNDLE_SCHEMA", "DEPRECATED_BUNDLE_SCHEMA");
    }
    const normalized = targets.map((target) => target.trim()).filter((target) => target.length > 0);
    if (normalized.length === 0) {
      throw new BookerError("MISSING_TARGETS", "MISSING_TARGETS");
    }
    return normalized;
  }
  /**
   * Return deprecation warnings for legacy Booker frontmatter structures.
   */
  getDeprecationWarnings(frontmatter, type, rawFrontmatter) {
    const warnings = [];
    if (type === "booker-recipe") {
      const recipeWarnings = this.getRecipeDeprecations(frontmatter, rawFrontmatter);
      warnings.push(...recipeWarnings);
    } else {
      const bundleWarnings = this.getBundleDeprecations(frontmatter, rawFrontmatter);
      warnings.push(...bundleWarnings);
    }
    return warnings;
  }
  getRecipeDeprecations(frontmatter, rawFrontmatter) {
    const warnings = [];
    if (frontmatter.options && typeof frontmatter.options === "object") {
      const optionKeys = this.collectOptionKeys(frontmatter.options);
      const keyed = optionKeys.length > 0 ? optionKeys.map((key) => `options.${key}`) : ["options"];
      const hint = optionKeys.length > 0 ? this.formatOptionHint("recipe", keyed) : "Move nested `options` values to `recipe_*` keys.";
      warnings.push(this.createDeprecation(
        "Deprecated recipe schema",
        keyed,
        ["options"],
        rawFrontmatter,
        hint
      ));
    }
    const unprefixedKeys = this.collectOptionKeys(frontmatter);
    if (unprefixedKeys.length > 0) {
      warnings.push(this.createDeprecation(
        "Deprecated unprefixed keys",
        unprefixedKeys,
        unprefixedKeys,
        rawFrontmatter,
        this.formatOptionHint("recipe", unprefixedKeys)
      ));
    }
    return warnings;
  }
  getBundleDeprecations(frontmatter, rawFrontmatter) {
    const warnings = [];
    const bundleKeys = [];
    const locationKeys = [];
    if (frontmatter.aggregate) {
      bundleKeys.push("aggregate");
      locationKeys.push("aggregate");
      const aggregateOptionKeys = this.collectOptionKeys(frontmatter.aggregate.options);
      if (aggregateOptionKeys.length > 0) {
        bundleKeys.push(...aggregateOptionKeys.map((key) => `aggregate.options.${key}`));
      }
    }
    if (frontmatter.build_options) {
      bundleKeys.push("build_options");
      locationKeys.push("build_options");
    }
    if (bundleKeys.length > 0) {
      warnings.push(this.createDeprecation(
        "Deprecated bundle schema",
        bundleKeys,
        locationKeys,
        rawFrontmatter,
        this.formatBundleHint(bundleKeys)
      ));
    }
    const unprefixedKeys = this.collectOptionKeys(frontmatter);
    if (unprefixedKeys.length > 0) {
      warnings.push(this.createDeprecation(
        "Deprecated unprefixed keys",
        unprefixedKeys,
        unprefixedKeys,
        rawFrontmatter,
        this.formatOptionHint("aggregate", unprefixedKeys)
      ));
    }
    const targets = frontmatter.targets;
    const invalidTargets = Array.isArray(targets) && targets.some((target) => typeof target !== "string");
    if (invalidTargets) {
      warnings.push(this.createDeprecation(
        "Deprecated bundle target schema",
        ["targets"],
        ["targets"],
        rawFrontmatter,
        "Replace inline target objects with a plain list of strings under `targets`."
      ));
    }
    return warnings;
  }
  resolveRecipeOptions(frontmatter) {
    const prefixed = this.readRecipePrefixedOptions(frontmatter);
    const nested = this.readOptionsFromObject(frontmatter.options);
    const unprefixed = this.readOptionsFromObject(frontmatter);
    return this.resolveOptionSources(prefixed, nested, unprefixed);
  }
  resolveBuildOptions(frontmatter) {
    var _a, _b, _c, _d;
    const prefixed = this.readBuildPrefixedOptions(frontmatter);
    const nested = this.readBuildOptionsFromObject(frontmatter.build_options);
    const resolved = {};
    const stopOnError = (_a = prefixed.stop_on_error) != null ? _a : nested.stop_on_error;
    if (stopOnError !== void 0) {
      resolved.stop_on_error = stopOnError;
    }
    const continueOnMissing = (_b = prefixed.continue_on_missing) != null ? _b : nested.continue_on_missing;
    if (continueOnMissing !== void 0) {
      resolved.continue_on_missing = continueOnMissing;
    }
    const dryRun = (_c = prefixed.dry_run) != null ? _c : nested.dry_run;
    if (dryRun !== void 0) {
      resolved.dry_run = dryRun;
    }
    const summaryNotice = (_d = prefixed.summary_notice) != null ? _d : nested.summary_notice;
    if (summaryNotice !== void 0) {
      resolved.summary_notice = summaryNotice;
    }
    return resolved;
  }
  readOptionsFromObject(source) {
    if (!source || typeof source !== "object") {
      return {};
    }
    const record = source;
    const options = {};
    const stripFrontmatter = this.readBoolean(record.strip_frontmatter);
    if (stripFrontmatter !== void 0) {
      options.strip_frontmatter = stripFrontmatter;
    }
    const stripH1 = this.readBoolean(record.strip_h1);
    if (stripH1 !== void 0) {
      options.strip_h1 = stripH1;
    }
    const stripTitle = this.readBoolean(record.strip_title);
    if (stripTitle !== void 0) {
      options.strip_title = stripTitle;
    }
    const separator = this.readString(record.separator);
    if (separator !== void 0) {
      options.separator = separator;
    }
    const headingOffset = this.readNumber(record.heading_offset);
    if (headingOffset !== void 0) {
      options.heading_offset = headingOffset;
    }
    const toc = this.readBoolean(record.toc);
    if (toc !== void 0) {
      options.toc = toc;
    }
    const tocTitle = this.readString(record.toc_title);
    if (tocTitle !== void 0) {
      options.toc_title = tocTitle;
    }
    const tocScope = this.readTocScope(record.toc_scope);
    if (tocScope !== void 0) {
      options.toc_scope = tocScope;
    }
    const tocDepth = this.readNumber(record.toc_depth);
    if (tocDepth !== void 0) {
      options.toc_depth = tocDepth;
    }
    const tocIncludeH1 = this.readBoolean(record.toc_include_h1);
    if (tocIncludeH1 !== void 0) {
      options.toc_include_h1 = tocIncludeH1;
    }
    return options;
  }
  readRecipePrefixedOptions(frontmatter) {
    return this.readPrefixedOptions(frontmatter, "recipe_");
  }
  readAggregatePrefixedOptions(frontmatter) {
    return this.readPrefixedOptions(frontmatter, "aggregate_");
  }
  readPrefixedOptions(frontmatter, prefix) {
    const options = {};
    const stripFrontmatter = this.readBoolean(frontmatter[`${prefix}strip_frontmatter`]);
    if (stripFrontmatter !== void 0) {
      options.strip_frontmatter = stripFrontmatter;
    }
    const stripH1 = this.readBoolean(frontmatter[`${prefix}strip_h1`]);
    if (stripH1 !== void 0) {
      options.strip_h1 = stripH1;
    }
    const stripTitle = this.readBoolean(frontmatter[`${prefix}strip_title`]);
    if (stripTitle !== void 0) {
      options.strip_title = stripTitle;
    }
    const separator = this.readString(frontmatter[`${prefix}separator`]);
    if (separator !== void 0) {
      options.separator = separator;
    }
    const headingOffset = this.readNumber(frontmatter[`${prefix}heading_offset`]);
    if (headingOffset !== void 0) {
      options.heading_offset = headingOffset;
    }
    const toc = this.readBoolean(frontmatter[`${prefix}toc`]);
    if (toc !== void 0) {
      options.toc = toc;
    }
    const tocTitle = this.readString(frontmatter[`${prefix}toc_title`]);
    if (tocTitle !== void 0) {
      options.toc_title = tocTitle;
    }
    const tocScope = this.readTocScope(frontmatter[`${prefix}toc_scope`]);
    if (tocScope !== void 0) {
      options.toc_scope = tocScope;
    }
    const tocDepth = this.readNumber(frontmatter[`${prefix}toc_depth`]);
    if (tocDepth !== void 0) {
      options.toc_depth = tocDepth;
    }
    const tocIncludeH1 = this.readBoolean(frontmatter[`${prefix}toc_include_h1`]);
    if (tocIncludeH1 !== void 0) {
      options.toc_include_h1 = tocIncludeH1;
    }
    return options;
  }
  resolveOptionSources(prefixed, nested, unprefixed) {
    var _a, _b;
    const resolved = {};
    for (const key of OPTION_KEYS) {
      const value = (_b = (_a = prefixed[key]) != null ? _a : nested[key]) != null ? _b : unprefixed[key];
      if (value !== void 0) {
        this.assignOption(resolved, key, value);
      }
    }
    return resolved;
  }
  assignOption(target, key, value) {
    target[key] = value;
  }
  readBuildPrefixedOptions(frontmatter) {
    const options = {};
    const stopOnError = this.readBoolean(frontmatter.build_stop_on_error);
    if (stopOnError !== void 0) {
      options.stop_on_error = stopOnError;
    }
    const continueOnMissing = this.readBoolean(frontmatter.build_continue_on_missing);
    if (continueOnMissing !== void 0) {
      options.continue_on_missing = continueOnMissing;
    }
    const dryRun = this.readBoolean(frontmatter.build_dry_run);
    if (dryRun !== void 0) {
      options.dry_run = dryRun;
    }
    const summaryNotice = this.readBoolean(frontmatter.build_summary_notice);
    if (summaryNotice !== void 0) {
      options.summary_notice = summaryNotice;
    }
    return options;
  }
  readBuildOptionsFromObject(source) {
    if (!source || typeof source !== "object") {
      return {};
    }
    const record = source;
    const options = {};
    const stopOnError = this.readBoolean(record.stop_on_error);
    if (stopOnError !== void 0) {
      options.stop_on_error = stopOnError;
    }
    const continueOnMissing = this.readBoolean(record.continue_on_missing);
    if (continueOnMissing !== void 0) {
      options.continue_on_missing = continueOnMissing;
    }
    const dryRun = this.readBoolean(record.dry_run);
    if (dryRun !== void 0) {
      options.dry_run = dryRun;
    }
    const summaryNotice = this.readBoolean(record.summary_notice);
    if (summaryNotice !== void 0) {
      options.summary_notice = summaryNotice;
    }
    return options;
  }
  readString(value) {
    if (typeof value !== "string") {
      return void 0;
    }
    return value;
  }
  readBoolean(value) {
    if (typeof value !== "boolean") {
      return void 0;
    }
    return value;
  }
  readNumber(value) {
    if (typeof value !== "number" || Number.isNaN(value)) {
      return void 0;
    }
    return value;
  }
  readTocScope(value) {
    if (value === "self") {
      return "file";
    }
    if (value === "file" || value === "tree") {
      return value;
    }
    return void 0;
  }
  collectOptionKeys(source) {
    if (!source || typeof source !== "object") {
      return [];
    }
    const record = source;
    return OPTION_KEYS.filter((key) => key in record);
  }
  hasAggregateOptionOverrides(frontmatter) {
    return [
      frontmatter.aggregate_strip_frontmatter,
      frontmatter.aggregate_strip_h1,
      frontmatter.aggregate_strip_title,
      frontmatter.aggregate_separator,
      frontmatter.aggregate_heading_offset,
      frontmatter.aggregate_toc,
      frontmatter.aggregate_toc_title,
      frontmatter.aggregate_toc_scope,
      frontmatter.aggregate_toc_depth,
      frontmatter.aggregate_toc_include_h1
    ].some((value) => value !== void 0);
  }
  createDeprecation(category, keys, locationKeys, rawFrontmatter, hint) {
    const location = rawFrontmatter ? this.findLocation(rawFrontmatter, locationKeys) : void 0;
    return {
      category,
      keys,
      location,
      hint
    };
  }
  formatOptionHint(scope, keys) {
    const prefix = scope === "recipe" ? "recipe_" : "aggregate_";
    const mapped = keys.map((key) => {
      var _a;
      const suffix = key.includes(".") ? (_a = key.split(".").pop()) != null ? _a : key : key;
      return `${prefix}${suffix}`;
    });
    const from = keys.join(", ");
    const to = mapped.join(", ");
    return `Move ${from} to ${to}.`;
  }
  formatBundleHint(keys) {
    const hints = [];
    if (keys.some((key) => key.startsWith("aggregate"))) {
      hints.push("Move `aggregate.output` to `aggregate_output` and `aggregate.options.*` to `aggregate_*` keys.");
    }
    if (keys.some((key) => key.startsWith("build_options"))) {
      hints.push("Move `build_options.*` to `build_*` keys.");
    }
    return hints.length > 0 ? hints.join(" ") : "Update aggregate and build configuration to the flat `aggregate_*` and `build_*` keys.";
  }
  findLocation(rawFrontmatter, keys) {
    var _a, _b;
    if (keys.length === 0) {
      return void 0;
    }
    const lines = rawFrontmatter.split(/\r?\n/);
    for (let index = 0; index < lines.length; index += 1) {
      const line = lines[index];
      if (line === void 0) {
        continue;
      }
      for (const key of keys) {
        const escaped = key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const match = line.match(new RegExp(`^(\\s*)${escaped}\\s*:`));
        if (match) {
          const indent = (_b = (_a = match[1]) == null ? void 0 : _a.length) != null ? _b : 0;
          return { line: index + 1, column: indent + 1 };
        }
      }
    }
    return void 0;
  }
};

// src/services/LinkResolver.ts
var LinkResolver = class {
  constructor(metadataCache) {
    this.metadataCache = metadataCache;
  }
  /**
   * Normalize a link string by trimming and extracting wikilink targets.
   *
   * @param raw - Raw link or path string.
   * @returns Normalized link target or trimmed path.
   */
  normalizeLinkString(raw) {
    const trimmed = raw.trim();
    if (trimmed.startsWith("[[") && trimmed.endsWith("]]")) {
      const inner = trimmed.slice(2, -2);
      const [target = ""] = inner.split("|");
      return target.trim();
    }
    return trimmed;
  }
  /**
   * Resolve a normalized link to a file reference.
   *
   * @param linkpath - Normalized link path.
   * @param fromPath - Source path for relative resolution.
   * @returns File reference when found, otherwise null.
   */
  resolveToFile(linkpath, fromPath) {
    return this.metadataCache.getFirstLinkpathDest(linkpath, fromPath);
  }
};

// src/services/MarkdownTransform.ts
var MAX_HEADING_LEVEL = 6;
var shiftHeadings = (markdown, offset) => {
  if (offset <= 0) {
    return markdown;
  }
  const lines = markdown.split("\n");
  let inFence = false;
  let fenceMarker;
  const shifted = lines.map((line) => {
    var _a, _b, _c;
    const fenceMatch = line.match(/^\s*(```+|~~~+)/);
    if (fenceMatch) {
      const marker = fenceMatch[1];
      if (!inFence) {
        inFence = true;
        fenceMarker = marker;
      } else if (fenceMarker && line.trimStart().startsWith(fenceMarker)) {
        inFence = false;
        fenceMarker = void 0;
      }
      return line;
    }
    if (inFence) {
      return line;
    }
    const headingMatch = line.match(/^(#{1,6})(\s+.*)$/);
    if (!headingMatch) {
      return line;
    }
    const level = (_b = (_a = headingMatch[1]) == null ? void 0 : _a.length) != null ? _b : 0;
    const adjusted = Math.min(level + offset, MAX_HEADING_LEVEL);
    const headingSuffix = (_c = headingMatch[2]) != null ? _c : "";
    return `${"#".repeat(adjusted)}${headingSuffix}`;
  });
  return shifted.join("\n");
};
var MarkdownTransform = class {
  /**
   * Strip a YAML frontmatter block from the start of content.
   *
   * @param content - Markdown content that may include frontmatter.
   * @returns Markdown content without the frontmatter block.
   */
  stripFrontmatter(content) {
    if (!content.startsWith("---")) {
      return content;
    }
    const match = content.match(/^---\s*\n[\s\S]*?\n---\s*\n?/);
    if (!match) {
      return content;
    }
    return content.slice(match[0].length);
  }
  /**
   * Remove the first H1 heading in the content, if present.
   *
   * @param content - Markdown content to adjust.
   * @returns Updated Markdown content.
   */
  stripFirstH1(content) {
    const lines = content.split("\n");
    const h1Index = lines.findIndex((line) => line.startsWith("# "));
    if (h1Index === -1) {
      return content;
    }
    const nextIndex = h1Index + 1;
    if (lines[nextIndex] === "") {
      lines.splice(h1Index, 2);
    } else {
      lines.splice(h1Index, 1);
    }
    return lines.join("\n");
  }
  /**
   * Apply configured content transforms such as frontmatter or H1 stripping.
   *
   * @param content - Markdown content to transform.
   * @param options - Booker options controlling the transforms.
   * @returns Updated Markdown content.
   */
  apply(content, options) {
    let output = content;
    if (options.strip_frontmatter) {
      output = this.stripFrontmatter(output);
    }
    if (options.strip_h1) {
      output = this.stripFirstH1(output);
    }
    return output;
  }
  /**
   * Apply the configured heading offset to Markdown content.
   */
  applyHeadingOffset(content, options) {
    var _a;
    const offset = (_a = options.heading_offset) != null ? _a : 1;
    return shiftHeadings(content, offset);
  }
  /**
   * Extract Markdown headings from content, ignoring fenced code blocks.
   */
  extractHeadings(content, sourcePath) {
    var _a, _b, _c, _d;
    const lines = content.split("\n");
    const headings = [];
    let inFence = false;
    let fenceMarker;
    for (const line of lines) {
      const fenceMatch = line.match(/^\s*(```+|~~~+)/);
      if (fenceMatch) {
        const marker = fenceMatch[1];
        if (!inFence) {
          inFence = true;
          fenceMarker = marker;
        } else if (fenceMarker && line.trimStart().startsWith(fenceMarker)) {
          inFence = false;
          fenceMarker = void 0;
        }
        continue;
      }
      if (inFence) {
        continue;
      }
      const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
      if (!headingMatch) {
        continue;
      }
      const level = (_b = (_a = headingMatch[1]) == null ? void 0 : _a.length) != null ? _b : 0;
      const text = (_d = (_c = headingMatch[2]) == null ? void 0 : _c.trim()) != null ? _d : "";
      headings.push({ level, text, sourcePath });
    }
    return headings;
  }
  /**
   * Join content chunks with the provided separator.
   *
   * @param chunks - Array of Markdown content chunks.
   * @param separator - Separator string to insert between chunks.
   * @returns Joined content string.
   */
  joinChunks(chunks, separator) {
    return chunks.join(separator);
  }
};

// src/services/TableOfContentsBuilder.ts
var LIST_INDENT = "  ";
var TableOfContentsBuilder = class {
  /**
   * Render a nested Markdown table of contents with Obsidian heading links.
   */
  render(headings, options) {
    var _a;
    if (!options.toc) {
      return "";
    }
    const filtered = headings.filter((heading) => {
      if (!options.toc_include_h1 && heading.level === 1) {
        return false;
      }
      return heading.level <= options.toc_depth;
    });
    const listLines = filtered.map((heading) => {
      const indent = LIST_INDENT.repeat(Math.max(heading.level - 1, 0));
      return `${indent}- [[#${heading.text}]]`;
    });
    const listBlock = listLines.join("\n");
    const title = (_a = options.toc_title) != null ? _a : "Table of Contents";
    if (title === "") {
      return listBlock;
    }
    if (!listBlock) {
      return `# ${title}`;
    }
    return `# ${title}

${listBlock}`;
  }
  /**
   * Insert a rendered table of contents into content, optionally after the document title.
   */
  apply(content, headings, options, insertAfterTitle) {
    var _a;
    const tocBlock = this.render(headings, options);
    if (!tocBlock) {
      return content;
    }
    const trimmedContent = content.trimEnd();
    const tocLines = tocBlock.split("\n");
    if (insertAfterTitle) {
      const lines = trimmedContent.split("\n");
      if ((_a = lines[0]) == null ? void 0 : _a.startsWith("# ")) {
        const insertIndex = lines[1] === "" ? 2 : 1;
        lines.splice(insertIndex, 0, ...tocLines, "");
        return `${lines.join("\n")}
`;
      }
    }
    return `${tocBlock}

${trimmedContent}`.trimEnd() + "\n";
  }
};

// src/services/UserMessagePresenter.ts
var _UserMessagePresenter = class _UserMessagePresenter {
  constructor(notice) {
    this.notice = notice;
  }
  /**
   * Format a notice message with the required emoji + file label prefix.
   *
   * @param level - Notice severity level to map to an emoji.
   * @param fileLabel - File label to show in brackets.
   * @param message - Notice body message.
   */
  formatNotice(level, fileLabel, message) {
    const prefix = this.getEmoji(level);
    return `${prefix} [${fileLabel}] ${message}`;
  }
  /**
   * Show an error notice for a file-related message.
   */
  showErrorForFile(fileLabel, message) {
    this.notice.notify(this.formatNotice("error", fileLabel, message));
  }
  /**
   * Show a warning notice for a file-related message.
   */
  showWarningForFile(fileLabel, message) {
    this.notice.notify(this.formatNotice("warning", fileLabel, message));
  }
  /**
   * Show a success notice for a file-related message.
   */
  showSuccessForFile(fileLabel, message) {
    this.notice.notify(this.formatNotice("success", fileLabel, message));
  }
  /**
   * Show an informational notice for a file-related message.
   */
  showInfoForFile(fileLabel, message) {
    this.notice.notify(this.formatNotice("info", fileLabel, message));
  }
  /**
   * Show an error notice that is not tied to a specific file.
   */
  showError(message) {
    this.showErrorForFile(_UserMessagePresenter.defaultLabel, message);
  }
  /**
   * Show a warning notice that is not tied to a specific file.
   */
  showWarning(message) {
    this.showWarningForFile(_UserMessagePresenter.defaultLabel, message);
  }
  /**
   * Show a success notice that is not tied to a specific file.
   */
  showSuccess(message) {
    this.showSuccessForFile(_UserMessagePresenter.defaultLabel, message);
  }
  /**
   * Show an informational notice that is not tied to a specific file.
   */
  showInfo(message) {
    this.showInfoForFile(_UserMessagePresenter.defaultLabel, message);
  }
  getEmoji(level) {
    switch (level) {
      case "error":
        return "\u274C";
      case "warning":
        return "\u26A0\uFE0F";
      case "success":
        return "\u2705";
      case "info":
      default:
        return "\u2139\uFE0F";
    }
  }
};
_UserMessagePresenter.defaultLabel = "Booker";
var UserMessagePresenter = _UserMessagePresenter;

// src/services/VaultIO.ts
var VaultIO = class {
  constructor(vault) {
    this.vault = vault;
  }
  /**
   * Ensure the output file exists, creating parent folders as needed.
   *
   * @param path - Output file path.
   * @returns File reference to the output file.
   */
  async ensureOutputFile(path) {
    const outputPath = normalizePath(path);
    await this.ensureFolderForPath(outputPath);
    const existing = this.vault.getFileByPath(outputPath);
    if (existing) {
      return existing;
    }
    return this.vault.create(outputPath, "");
  }
  /**
   * Read file contents from the vault.
   *
   * @param file - File reference to read.
   * @returns File contents.
   */
  async read(file) {
    return this.vault.read(file);
  }
  /**
   * Write content to a vault file.
   *
   * @param file - File reference to write.
   * @param content - Content to write.
   */
  async write(file, content) {
    await this.vault.modify(file, content);
  }
  async ensureFolderForPath(path) {
    const lastSlash = path.lastIndexOf("/");
    if (lastSlash === -1) {
      return;
    }
    const folderPath = path.slice(0, lastSlash);
    if (!folderPath) {
      return;
    }
    const existing = this.vault.getFileByPath(folderPath);
    if (!existing || existing.kind !== "folder") {
      await this.vault.createFolder(folderPath);
    }
  }
};

// src/app/BookerContext.ts
var BookerContext = class {
  constructor(app) {
    const appContext = new ObsidianAppContext(app);
    this.app = app;
    this.vault = appContext.vault;
    this.metadataCache = appContext.metadataCache;
    this.workspace = app.workspace;
    this.presenter = new UserMessagePresenter(appContext.notice);
    this.linkResolver = new LinkResolver(this.metadataCache);
    this.parser = new FrontmatterParser(this.metadataCache);
    this.markdownTransform = new MarkdownTransform();
    this.tocBuilder = new TableOfContentsBuilder();
    this.vaultIO = new VaultIO(this.vault);
    this.compiler = new Compiler({
      linkResolver: this.linkResolver,
      vaultIO: this.vaultIO,
      markdownTransform: this.markdownTransform,
      tocBuilder: this.tocBuilder
    });
    this.buildRunner = new BuildRunner({
      compiler: this.compiler,
      parser: this.parser,
      linkResolver: this.linkResolver,
      presenter: this.presenter,
      vault: this.vault
    });
    const prompt = (message, defaultValue) => new FilenameModal(app, message, defaultValue).openAndGetValue();
    const openFile = (file) => {
      const resolved = app.vault.getAbstractFileByPath(file.path);
      if (resolved instanceof import_obsidian5.TFile) {
        void app.workspace.getLeaf(false).openFile(resolved);
      }
    };
    this.fileCreator = new BookerFileCreator({
      vault: this.vault,
      presenter: this.presenter,
      parser: this.parser,
      prompt,
      openFile
    });
    this.panelModelBuilder = new BookerPanelModelBuilder({
      vault: this.vault,
      metadataCache: this.metadataCache,
      parser: this.parser,
      linkResolver: this.linkResolver
    });
  }
  /**
   * Open a generated output path in the workspace.
   *
   * @param path - Vault path to open.
   * @returns Whether the file was opened successfully.
   */
  openOutput(path) {
    const resolved = this.app.vault.getAbstractFileByPath(path);
    if (resolved instanceof import_obsidian5.TFile) {
      void this.app.workspace.getLeaf(false).openFile(resolved);
      return true;
    }
    return false;
  }
};

// src/main.ts
var BOOKER_ICON_SVG = `
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 24 24"
     fill="none"
     stroke="currentColor"
     stroke-width="2"
     stroke-linecap="round"
     stroke-linejoin="round">
  <path d="M12 2 2 7l10 5 10-5-10-5z"/>
  <path d="M2 17l10 5 10-5"/>
  <path d="M2 12l10 5 10-5"/>
</svg>
`;
var BOOKER_ICON_ID = "lp-booker";
var BookerPlugin = class extends import_obsidian6.Plugin {
  /**
   * Initialize Booker services, views, and commands on plugin load.
   */
  async onload() {
    const context = new BookerContext(this.app);
    const presenter = context.presenter;
    const buildRunner = context.buildRunner;
    const fileCreator = context.fileCreator;
    this.registerView(
      VIEW_TYPE_BOOKER_PANEL,
      (leaf) => new BookerPanelView(
        leaf,
        context.panelModelBuilder,
        (file) => buildRunner.buildCurrentFile(file),
        (path) => context.openOutput(path),
        presenter
      )
    );
    this.addCommand({
      id: "booker-build-current-file",
      name: "Booker: Generate current file",
      callback: () => {
        void this.buildCurrentFile(buildRunner, presenter);
      }
    });
    this.addCommand({
      id: "booker-toggle-panel",
      name: "Booker: Toggle panel",
      callback: () => {
        void this.togglePanel();
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        this.addBookerContextMenu(menu, file, fileCreator);
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.refreshPanelViews();
      })
    );
    (0, import_obsidian6.addIcon)(BOOKER_ICON_ID, BOOKER_ICON_SVG);
    this.addRibbonIcon(
      BOOKER_ICON_ID,
      // lucide icon name
      "Toggle Booker panel",
      () => {
        void this.togglePanel();
      }
    );
  }
  async buildCurrentFile(buildRunner, presenter) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      presenter.showInfo("No active file to generate.");
      return;
    }
    const fileRef = createFileRef(activeFile);
    await buildRunner.buildCurrentFile(fileRef);
  }
  addBookerContextMenu(menu, file, fileCreator) {
    const target = this.getTargetRef(file);
    menu.addItem((item) => {
      var _a;
      item.setTitle("Booker");
      const anyItem = item;
      const sub = typeof anyItem.setSubmenu === "function" ? anyItem.setSubmenu() : (_a = anyItem.submenu) != null ? _a : null;
      const m = sub != null ? sub : menu;
      m.addItem((i) => {
        i.setTitle("New recipe");
        i.onClick(() => void fileCreator.createRecipe(target));
      });
      m.addItem((i) => {
        i.setTitle("New bundle");
        i.onClick(() => void fileCreator.createBundle(target));
      });
    });
  }
  /**
   * Resolve the target folder reference for context menu actions.
   */
  getTargetRef(file) {
    var _a;
    if (!file) {
      const root2 = this.app.vault.getRoot();
      return { path: root2.path, kind: "folder" };
    }
    if (file instanceof import_obsidian6.TFolder) {
      return { path: file.path, kind: "folder" };
    }
    if (file instanceof import_obsidian6.TFile) {
      const parent = (_a = file.parent) != null ? _a : this.app.vault.getRoot();
      return { path: parent.path, kind: "folder" };
    }
    const root = this.app.vault.getRoot();
    return { path: root.path, kind: "folder" };
  }
  /**
   * Toggle the Booker panel in the right sidebar.
   */
  async togglePanel() {
    const existing = this.app.workspace.getLeavesOfType(VIEW_TYPE_BOOKER_PANEL);
    const [openLeaf] = existing;
    if (openLeaf) {
      this.app.workspace.revealLeaf(openLeaf);
      return;
    }
    const leaf = this.app.workspace.getRightLeaf(false);
    if (!leaf) {
      return;
    }
    await leaf.setViewState({ type: VIEW_TYPE_BOOKER_PANEL, active: true });
    this.app.workspace.revealLeaf(leaf);
    this.refreshPanelViews();
  }
  /**
   * Refresh all open Booker panel views with the current active file.
   */
  refreshPanelViews() {
    const activeFile = this.app.workspace.getActiveFile();
    const fileRef = activeFile ? createFileRef(activeFile) : null;
    this.app.workspace.getLeavesOfType(VIEW_TYPE_BOOKER_PANEL).forEach((leaf) => {
      const view = leaf.view;
      if (view instanceof BookerPanelView) {
        view.setActiveFile(fileRef);
      }
    });
  }
};
